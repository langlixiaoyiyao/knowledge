# js的模块化
## 浏览器中模块的加载
加载模块涉及其中执行其中的代码，但必须是所有依赖模块都加载并且执行完成。直到所有依赖模块都加载完成，才会执行入口模块。
## es6的模块化
```js
// es6的导入语法
import "" from "";

// es6的导出语法
export const a = 3;
export default b = 2;
```
### 特点
1、其模块的依赖关系是在编译时就已经确定好了的。   
2、不能用动态语句去import "" from ""。   
3、可以通过 import("")去动态加载。   
4、可以直接在浏览器中运行。   
## commonJs的模块化
commonjs是nodeJs的模块化方案，在nodeJs中，一个文件就是一个模块。   
```js
// 导入语法
const { a, b } = require("a-b");
const xixi = require("xixi");
// 导出语法 exports = module.exports = {}
exports.name = 'q';
module.exports = { // 默认导出
  a: 1,
  b: 2,
}
// 错误写法如下
exports = {
  a: 1,
}
```
### 特点
1、同步方式加载模块。   
2、浏览器无法使用，因为其采用同步方式加载模块，而模块文件放在服务器端，中间需要通过网络请求去获取模块，很不稳定。   
3、支持动态语言特性。  
## AMD模块
需要先引入Require.js。   
AMD模块推崇依赖前置。当模块被加载时，模块加载器会先确保当前模块的依赖模块全被下载并执行，然后这些依赖模块会以形参的形式被注入。   
```js
require(['axios', 'lodash'], function(axios, lodash) {
  
})
```

## 不同模块点的比较
| 模块         | 执行时机 | 导出的值的类型 | 加载模块的方式 | 是否可以采用条件语句动态加载 |
| ----------- | ----------- | ------- | -------- | -------- |
| ESM | 编译时加载、运行模块 | 输出的是值的引用 | 异步加载 | 否 |
| commonjs | 运行时加载运行 | 输出的是值的拷贝 | 同步加载 | 是 |
